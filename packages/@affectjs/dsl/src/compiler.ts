/**
 * Fluent-FFmpeg DSL Compiler
 *
 * Compiles AST generated by Peggy parser to executable JavaScript code
 */

export interface ASTNode {
    type: string;
    [key: string]: any;
}

export interface Program {
    type: "Program";
    commands: ASTNode[];
}

export interface ConvertBlock {
    type: "ConvertBlock";
    commands: ASTNode[];
}

export interface AffectBlock {
    type: "AffectBlock";
    mediaType: "auto" | "video" | "audio" | "image";
    commands: ASTNode[];
}

/**
 * Compile AST to JavaScript code
 */
export interface CompileOptions {
    context?: Record<string, any>;
    warnings?: boolean; // Enable/disable warnings (default: true)
}

export function compileToJs(
    ast: Program | ConvertBlock | AffectBlock,
    options?: CompileOptions
): string {
    const lines: string[] = [];
    const context = options?.context || {};
    const warningsEnabled = options?.warnings !== false; // Default to true
    const warnings: string[] = [];

    // Header
    lines.push("// Generated code from @affectjs/dsl");
    lines.push("const { affect } = require('@affectjs/affect');");
    lines.push("");

    // Extract input and output from commands
    const commands =
        ast.type === "ConvertBlock" ||
        ast.type === "Program" ||
        ast.type === "AffectBlock"
            ? ast.commands
            : [];

    // Find input and output
    let inputValue: any = null;
    let outputValue: any = null;
    let mediaType = "auto";

    if (ast.type === "AffectBlock") {
        mediaType = ast.mediaType || "auto";
        const inputCmd = commands.find((cmd) => cmd.type === "Input");
        const outputCmd = commands.find((cmd) => cmd.type === "Save");

        if (inputCmd && inputCmd.path) {
            inputValue = inputCmd.path;
        }
        if (outputCmd && outputCmd.path) {
            outputValue = outputCmd.path;
        }
    }

    // Resolve variables
    const resolveValue = (value: any): string => {
        if (value && typeof value === "object") {
            if (value.type === "Variable") {
                const varName = value.name;
                if (context[varName] !== undefined) {
                    return JSON.stringify(context[varName]);
                }
                // Return context access expression
                return `context.${varName}`;
            } else if (value.type === "Literal") {
                return JSON.stringify(value.value);
            }
        }
        if (typeof value === "string") {
            return JSON.stringify(value);
        }
        return JSON.stringify(value);
    };

    const input = resolveValue(inputValue);
    const output = outputValue ? resolveValue(outputValue) : null;

    // Check if any commands use conditional logic
    const hasConditions = commands.some((cmd: any) => {
        if (cmd.type === "IfBlock") return true;
        // Check nested commands in blocks
        if (cmd.commands && Array.isArray(cmd.commands)) {
            return cmd.commands.some((subCmd: any) => subCmd.type === "IfBlock");
        }
        return false;
    });
    
    // Generate affect call (chain style)
    // For conditional logic, we need to get metadata first and use variable assignment
    if (hasConditions) {
        lines.push(`// Get metadata for conditional logic`);
        lines.push(`const metadata = await affect(${input}).getMetadata();`);
        lines.push(`let result = affect(${input});`);
    } else {
        lines.push(`const result = await affect(${input})`);
    }

    // Filter operations based on media type
    // If media type is 'image', ignore video and audio commands
    // If media type is 'audio', ignore video commands
    // If media type is 'video' or 'auto', keep all commands
    const videoCommandTypes = [
        "VideoBlock",
        "VideoCodec",
        "VideoBitrate",
        "VideoSize",
        "VideoFPS",
        "VideoFilter",
        "NoVideo",
    ];
    const audioCommandTypes = [
        "AudioBlock",
        "AudioCodec",
        "AudioBitrate",
        "AudioChannels",
        "AudioFrequency",
        "NoAudio",
    ];

    const shouldIgnoreCommand = (cmd: any): boolean => {
        if (cmd.type === "Input" || cmd.type === "Save") {
            return true; // Always skip Input and Save
        }

        // For image media type, ignore video and audio commands
        if (mediaType === "image") {
            const isVideoCmd = videoCommandTypes.includes(cmd.type);
            const isAudioCmd = audioCommandTypes.includes(cmd.type);

            if (warningsEnabled && (isVideoCmd || isAudioCmd)) {
                const cmdName = isVideoCmd ? "video" : "audio";
                warnings.push(
                    `Warning: ${cmdName} commands are ignored for image media type (command: ${cmd.type})`
                );
            }

            return isVideoCmd || isAudioCmd;
        }

        // For audio media type, ignore video commands
        if (mediaType === "audio") {
            const isVideoCmd = videoCommandTypes.includes(cmd.type);

            if (warningsEnabled && isVideoCmd) {
                warnings.push(
                    `Warning: video commands are ignored for audio media type (command: ${cmd.type})`
                );
            }

            return isVideoCmd;
        }

        // For video or auto, keep all commands
        return false;
    };

    // Process operations (filter based on media type)
    const operations = commands.filter((cmd) => !shouldIgnoreCommand(cmd));

    // Helper function to compile condition expression
    const compileCondition = (condition: any): string => {
        if (!condition) return "true";
        
        switch (condition.type) {
            case "Comparison":
                const left = compileValue(condition.left);
                const right = compileValue(condition.right);
                return `(${left} ${condition.operator} ${right})`;
            
            case "LogicalAnd":
                return `(${compileCondition(condition.left)} && ${compileCondition(condition.right)})`;
            
            case "LogicalOr":
                return `(${compileCondition(condition.left)} || ${compileCondition(condition.right)})`;
            
            case "UnaryNot":
                return `!${compileCondition(condition.expr)}`;
            
            default:
                return compileValue(condition);
        }
    };
    
    // Helper function to compile value expression
    const compileValue = (value: any): string => {
        if (!value) return "undefined";
        
        if (typeof value === "string" || typeof value === "number") {
            return JSON.stringify(value);
        }
        
        if (value.type === "Property") {
            // Property access like width, height, duration, etc.
            // These need to be accessed from media metadata at runtime
            return `metadata.${value.name}`;
        }
        
        if (value.type === "Variable") {
            const varName = value.name;
            if (context[varName] !== undefined) {
                return JSON.stringify(context[varName]);
            }
            return `context.${varName}`;
        }
        
        if (value.type === "Literal") {
            return JSON.stringify(value.value);
        }
        
        return JSON.stringify(value);
    };

    // Helper function to add a chain method call
    const addChainCall = (methodCall: string, indentLevel: number = 0) => {
        const indent = "  ".repeat(indentLevel);
        if (hasConditions) {
            // When conditions are present, use variable assignment
            lines.push(`${indent}result = result${methodCall};`);
        } else {
            // Normal chain call
            lines.push(`${indent}${methodCall}`);
        }
    };

    // Helper function to process a single command
    const processCommand = (cmd: any, inConditionBlock: boolean = false) => {
        const baseIndent = inConditionBlock ? (hasConditions ? 1 : 0) : 0;
        switch (cmd.type) {
            // Conditional logic
            case "IfBlock":
                const conditionCode = compileCondition(cmd.condition);
                const indent = "  ".repeat(baseIndent);
                lines.push(`${indent}if (${conditionCode}) {`);
                
                // Process then commands
                if (cmd.thenCommands && Array.isArray(cmd.thenCommands)) {
                    cmd.thenCommands.forEach((subCmd: any) => processCommand(subCmd, true));
                }
                
                // Process else commands if present
                if (cmd.elseCommands && cmd.elseCommands.length > 0) {
                    lines.push(`${indent}} else {`);
                    cmd.elseCommands.forEach((subCmd: any) => processCommand(subCmd, true));
                }
                
                lines.push(`${indent}}`);
                break;
            
            // Grouped blocks - expand commands
            case "VideoBlock":
                if (cmd.commands && Array.isArray(cmd.commands)) {
                    cmd.commands.forEach((subCmd: any) =>
                        processCommand(subCmd)
                    );
                }
                break;

            case "AudioBlock":
                if (cmd.commands && Array.isArray(cmd.commands)) {
                    cmd.commands.forEach((subCmd: any) =>
                        processCommand(subCmd)
                    );
                }
                break;

            case "FilterBlock":
                if (cmd.commands && Array.isArray(cmd.commands)) {
                    cmd.commands.forEach((subCmd: any) =>
                        processCommand(subCmd)
                    );
                }
                break;

            // Unified commands
            case "Resize":
                const width = cmd.width === "auto" ? "auto" : cmd.width;
                const height =
                    cmd.height === "auto" || cmd.height === null
                        ? "auto"
                        : cmd.height;
                addChainCall(
                    `.resize(${JSON.stringify(width)}, ${
                        height !== null ? JSON.stringify(height) : "undefined"
                    })`,
                    baseIndent
                );
                break;

            case "Encode":
                const codec = cmd.codec;
                const param = cmd.param;
                addChainCall(
                    `.encode(${JSON.stringify(codec)}, ${
                        param !== null && param !== undefined
                            ? JSON.stringify(param)
                            : "undefined"
                    })`,
                    baseIndent
                );
                break;

            case "Filter":
                const filterName = cmd.name;
                const filterValue = cmd.value;
                addChainCall(
                    `.filter(${JSON.stringify(filterName)}, ${
                        filterValue !== null && filterValue !== undefined
                            ? JSON.stringify(filterValue)
                            : "undefined"
                    })`,
                    baseIndent
                );
                break;

            case "Crop":
                let cropCall: string;
                if (cmd.region) {
                    cropCall = `.crop(${JSON.stringify(cmd.region)}, ${cmd.width}, ${cmd.height})`;
                } else {
                    const x =
                        cmd.x === "center" ? '"center"' : JSON.stringify(cmd.x);
                    const y =
                        cmd.y === "auto" || cmd.y === null
                            ? '"auto"'
                            : JSON.stringify(cmd.y);
                    cropCall = `.crop(${x}, ${y}, ${cmd.width}, ${cmd.height})`;
                }
                addChainCall(cropCall, baseIndent);
                break;

            case "Rotate":
                addChainCall(
                    `.rotate(${cmd.angle}, ${
                        cmd.flip ? JSON.stringify(cmd.flip) : "undefined"
                    })`,
                    baseIndent
                );
                break;

            // Video commands
            case "VideoCodec":
                addChainCall(`.videoCodec(${JSON.stringify(cmd.codec)})`, baseIndent);
                break;

            case "VideoBitrate":
                addChainCall(`.videoBitrate(${JSON.stringify(cmd.bitrate)})`, baseIndent);
                break;

            case "VideoSize":
                addChainCall(`.size(${JSON.stringify(cmd.size)})`, baseIndent);
                break;

            case "VideoFPS":
                addChainCall(`.fps(${cmd.fps})`, baseIndent);
                break;

            case "VideoFilter":
                if (typeof cmd.filter === "string") {
                    addChainCall(`.videoFilters(${JSON.stringify(cmd.filter)})`, baseIndent);
                } else {
                    const filterObj = JSON.stringify(cmd.filter);
                    addChainCall(`.videoFilters(${filterObj})`, baseIndent);
                }
                break;

            case "NoVideo":
                addChainCall(`.noVideo()`, baseIndent);
                break;

            // Audio commands
            case "AudioCodec":
                addChainCall(`.audioCodec(${JSON.stringify(cmd.codec)})`, baseIndent);
                break;

            case "AudioBitrate":
                addChainCall(`.audioBitrate(${JSON.stringify(cmd.bitrate)})`, baseIndent);
                break;

            case "AudioChannels":
                addChainCall(`.audioChannels(${cmd.channels})`, baseIndent);
                break;

            case "AudioFrequency":
                addChainCall(`.audioFrequency(${cmd.frequency})`, baseIndent);
                break;

            case "NoAudio":
                addChainCall(`.noAudio()`, baseIndent);
                break;

            // Options
            case "Timeout":
                addChainCall(`.options({ timeout: ${cmd.timeout} })`, baseIndent);
                break;

            case "Format":
                addChainCall(`.format(${JSON.stringify(cmd.format)})`, baseIndent);
                break;

            // Legacy commands (for backward compatibility)
            default:
                // Ignore unknown operations
                break;
        }
    };

    // Process each operation
    for (const op of operations) {
        processCommand(op);
    }

    // Add save if output is specified
    // Note: fluent-ffmpeg's save() always adds -y (overwrite) by default
    // We add -n to prevent overwrite by default (user should handle file existence check)
    if (output) {
        if (hasConditions) {
            lines.push(`result = result.outputOptions('-n');`);
            lines.push(`result = result.save(${output});`);
        } else {
            lines.push(`  .outputOptions('-n')`);
            lines.push(`  .save(${output})`);
        }
    }

    // Execute
    if (hasConditions) {
        lines.push(`const finalResult = await result.execute();`);
        lines.push("");
        lines.push("return finalResult;");
    } else {
        lines.push(`  .execute();`);
        lines.push("");
        lines.push("return result;");
    }

    // Check if context variables are used
    const usesContext = commands.some((cmd) => {
        if (
            cmd.type === "Input" &&
            cmd.path &&
            typeof cmd.path === "object" &&
            cmd.path.type === "Variable"
        ) {
            return true;
        }
        if (
            cmd.type === "Save" &&
            cmd.path &&
            typeof cmd.path === "object" &&
            cmd.path.type === "Variable"
        ) {
            return true;
        }
        return false;
    });

    // Wrap in async function if context is used
    let finalCode: string;
    if (usesContext) {
        const functionBody = lines.join("\n");
        finalCode = `async function execute(context = {}) {\n${functionBody
            .split("\n")
            .map((l) => "  " + l)
            .join("\n")}\n}`;
    } else {
        finalCode = lines.join("\n");
    }

    // Add warnings as comments if any
    if (warningsEnabled && warnings.length > 0) {
        const warningComments = warnings.map((w) => `// ${w}`).join("\n");
        return `${warningComments}\n\n${finalCode}`;
    }

    return finalCode;
}
